option HAS_DIFFUSE_TEXTURE: bool;
option HAS_ALPHA_TEXTURE: bool;
option ALPHA_TEST: bool;

[layout(std140)]
struct BasicSettings
{
	AlphaThreshold: f32,
	DiffuseColor: vec4<f32>
}

[layout(std140)]
struct InstanceData
{
	worldMatrix: mat4<f32>,
	invWorldMatrix: mat4<f32>
}

[layout(std140)]
struct ViewerData
{
	projectionMatrix: mat4<f32>,
	invProjectionMatrix: mat4<f32>,
	viewMatrix: mat4<f32>,
	invViewMatrix: mat4<f32>,
	viewProjMatrix: mat4<f32>,
	invViewProjMatrix: mat4<f32>,
	renderTargetSize: vec2<f32>,
	invRenderTargetSize: vec2<f32>,
	eyePosition: vec3<f32>
}

external
{
	[binding(5)] viewerData: uniform<ViewerData>,
	[binding(4)] instanceData: uniform<InstanceData>,
	[binding(3)] settings: uniform<BasicSettings>,
	[binding(0)] MaterialAlphaMap: sampler2D<f32>,
	[binding(1)] MaterialDiffuseMap: sampler2D<f32>,
	[binding(2)] TextureOverlay: sampler2D<f32>
}

struct InputData
{
	[location(0)] vertNormal: vec3<f32>,
	[location(1)] vertUV: vec2<f32>,
	[location(2)] vertPos: vec3<f32>
}

struct OutputData
{
	[location(0)] diffuseMap: vec4<f32>,
	[location(1)] normalMap: vec4<f32>,
	[location(2)] positionMap: vec4<f32>
}

[entry(frag)]
fn main(input: InputData) -> OutputData
{
	let textureColor = select_opt(HAS_DIFFUSE_TEXTURE, MaterialDiffuseMap.Sample(input.vertUV) * settings.DiffuseColor, settings.DiffuseColor);
	let alpha = select_opt(HAS_ALPHA_TEXTURE, MaterialAlphaMap.Sample(input.vertUV).x * textureColor.w, 1.0);
	/*if ((select_opt(ALPHA_TEST, var0.w < settings.AlphaThreshold, false)) == (true))
	{
		discard;
	}*/

	let output: OutputData;
	output.diffuseMap = textureColor;
	output.normalMap = vec4<f32>((vec3<f32>(1.0, 1.0, 1.0) + input.vertNormal) * 0.5, 1.0);
	output.positionMap = vec4<f32>(input.vertPos, 1.0);
	return output;
}
